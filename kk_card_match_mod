import json
import os
import zipfile
from pathlib import Path
from xml.etree import ElementTree as ET
from kkloader import KoikatuCharaData


def get_zip_mod_guid(mod_dir):
    try:
        with zipfile.ZipFile(mod_dir, 'r') as zip_ref:
            # 获取所有文件列表
            file_list = zip_ref.namelist()

            # 查找 ZIP 中的 XML 文件（假设只有一个）
            xml_files = [f for f in file_list if f.lower().endswith('.xml')]

            if not xml_files:
                print("ZIP 文件中没有 XML 文件")
                return None
            else:
                # 读取第一个 XML 文件
                xml_file = xml_files[0]
                with zip_ref.open(xml_file) as file:
                    xml_content = file.read().decode('utf-8')  # 如果是二进制 XML，可去掉 decode()
                    # print(xml_content)
                    root = ET.fromstring(xml_content)
                    result = {elem.tag: elem.text or None for elem in root}
                    result['schema-ver'] = root.attrib['schema-ver']  # 添加属性
                    # print(result)
                    return result
    except Exception as e:
        print(e)
        return None


def find_all_zipmod(root_dir):
    print(type(Path(root_dir).glob('**/*.zipmod')))
    for zipmod_path in Path(root_dir).glob('**/*.zipmod'):
        print(zipmod_path)


"""
在mod的根目录下执行 或者指定根目录 没有指定更目录就获取当前脚本的执行目录作为根目录获取mod
将mod信息存储为json文件 
如果没有json文件扫描mod，将mod信息存储为json文件
有json解析卡片信息获取所需mod的guid
根据guid获取卡片的mod路径
"""


# 生成mod的guid和mod路径映射json
def generate_KK_mod_json_file(mod_dir_path, kk_mod_json_file_path):
    kk_mod_map = {}
    for zipmod_path in Path(mod_dir_path).glob('**/*.zipmod'):
        zip_mod_data_map = get_zip_mod_guid(zipmod_path)
        print(zip_mod_data_map)
        if zip_mod_data_map:
            kk_mod_map[zip_mod_data_map['guid']] = {'name': zip_mod_data_map['name'],
                                                    'mod_dir': get_relative_path(zipmod_path, mod_dir_path)}
    with open(kk_mod_json_file_path, "w", encoding="utf-8") as f:
        json.dump(kk_mod_map, f, indent=4, ensure_ascii=False)  # ensure_ascii=False 支持中文


# 去掉根路径
def get_relative_path(full_path, root_path):
    try:
        return str(Path(full_path).relative_to(Path(root_path)))
    except ValueError:
        return full_path  # 或者返回原路径


if __name__ == '__main__':

    # 定义kk mod的根路径 没有指定就获取当前脚本执行路径
    script_dir = "D:\\ForCharactersLoading"
    # mod json资源更新标志 0=不更新 1=更新
    kk_mod_update_flag = 0
    # 定义卡片路径信息
    kk_card_path = "C:\\Users\\saltedfiah\\Desktop\\qiyana.png"

    if script_dir is None:
        script_dir = os.path.dirname(os.path.abspath(__file__))

    # 定义mod json文件名
    kk_mod_mod_json_file_name = 'kk_mod.json'
    # 指定json文件路径
    kk_mod_json_file_path = os.path.join(script_dir, kk_mod_mod_json_file_name)

    if not os.path.isfile(kk_mod_json_file_path) or kk_mod_update_flag == 1:
        generate_KK_mod_json_file(script_dir, kk_mod_json_file_path)

    with open(kk_mod_json_file_path, "r", encoding="utf-8") as f:
        kk_mod_json = json.load(f)

    current_card_mod_dir_map = {}
    kc = KoikatuCharaData.load(kk_card_path)
    for guid in kc['KKEx']['MigrationHelper'][1]['Info'].keys():
        print(guid)
        mod_info = kk_mod_json.get(guid, None)
        if mod_info:
            current_card_mod_dir_map[guid] = mod_info['mod_dir']
        else:
            current_card_mod_dir_map[guid] = "Not Found"
    print(current_card_mod_dir_map)
